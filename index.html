<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Super Mario Adventure</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            overflow: hidden;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: 'Press Start 2P', cursive;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: white;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 1280px;
            max-height: 720px;
            background: #000;
            box-shadow: 0 0 60px rgba(255, 100, 50, 0.3), 0 0 100px rgba(0, 0, 0, 0.8);
            border-radius: 8px;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #ui {
            position: absolute;
            top: 15px;
            left: 20px;
            text-shadow: 3px 3px 0 #000, -1px -1px 0 #000;
            z-index: 10;
            pointer-events: none;
            font-size: 14px;
        }

        #ui > div { margin-bottom: 8px; }
        #ui .label { color: #ffd700; }
        #ui .value { color: #fff; }

        #coins-display { color: #ffd700; }
        #lives-display { color: #ff6b6b; }
        #score-display { color: #fff; }

        #overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            transition: opacity 0.5s;
        }

        .hidden { opacity: 0; pointer-events: none; }

        h1 {
            font-size: 2.5rem;
            color: #ff6b6b;
            margin-bottom: 10px;
            text-align: center;
            text-shadow: 4px 4px 0 #c0392b, 6px 6px 0 #000;
            animation: titlePulse 2s ease-in-out infinite;
        }

        @keyframes titlePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .subtitle {
            font-size: 1rem;
            color: #ffd700;
            margin-bottom: 30px;
            text-shadow: 2px 2px 0 #000;
        }

        p {
            font-size: 0.8rem;
            line-height: 2;
            text-align: center;
            color: #aaa;
            margin-bottom: 30px;
        }

        button {
            background: linear-gradient(to bottom, #e74c3c, #c0392b);
            border: 4px solid #fff;
            color: white;
            padding: 18px 40px;
            font-size: 1rem;
            font-family: inherit;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 6px 0 #922b21, 0 8px 15px rgba(0,0,0,0.5);
            transition: all 0.1s;
            border-radius: 8px;
        }

        button:hover {
            background: linear-gradient(to bottom, #ff6b6b, #e74c3c);
            transform: translateY(-2px);
            box-shadow: 0 8px 0 #922b21, 0 10px 20px rgba(0,0,0,0.5);
        }

        button:active {
            transform: translateY(4px);
            box-shadow: 0 2px 0 #922b21;
        }

        .key-guide {
            margin-top: 25px;
            font-size: 0.65rem;
            color: #666;
            line-height: 2.2;
        }

        .key {
            display: inline-block;
            border: 2px solid #555;
            padding: 4px 10px;
            border-radius: 6px;
            background: linear-gradient(to bottom, #444, #222);
            color: #fff;
            margin: 0 3px;
            box-shadow: 0 3px 0 #111;
        }

        .mario-logo {
            width: 200px;
            height: 60px;
            margin-bottom: 20px;
        }

        #level-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            color: #ffd700;
            text-shadow: 4px 4px 0 #000;
            z-index: 15;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        #boss-health-container {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #boss-health-container.visible { opacity: 1; }

        .boss-name {
            text-align: center;
            color: #ff6b6b;
            font-size: 0.8rem;
            margin-bottom: 5px;
            text-shadow: 2px 2px 0 #000;
        }

        #boss-health-bar {
            width: 100%;
            height: 20px;
            background: #333;
            border: 3px solid #fff;
            border-radius: 10px;
            overflow: hidden;
        }

        #boss-health-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, #ff6b6b, #c0392b);
            transition: width 0.3s;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="canvas"></canvas>
    
    <div id="ui">
        <div><span class="label">MARIO</span></div>
        <div><span class="label">SCORE:</span> <span id="score-display" class="value">000000</span></div>
        <div><span class="label">COINS:</span> <span id="coins-display" class="value">×00</span></div>
        <div><span class="label">WORLD:</span> <span id="level-display" class="value">1-1</span></div>
        <div><span class="label">LIVES:</span> <span id="lives-display" class="value">×3</span></div>
    </div>

    <div id="level-indicator">WORLD 1-1</div>

    <div id="boss-health-container">
        <div class="boss-name">★ BOWSER ★</div>
        <div id="boss-health-bar">
            <div id="boss-health-fill"></div>
        </div>
    </div>

    <div id="overlay">
        <h1 id="title-text">SUPER MARIO<br>ADVENTURE</h1>
        <p class="subtitle">The Ultimate Platformer Experience</p>
        <p id="desc-text">
            Rescue the Princess from Bowser!<br>
            Jump, Run, and Defeat Enemies!
        </p>
        <button id="start-btn">★ GAME START ★</button>
        <div class="key-guide">
            Move: <span class="key">←</span> <span class="key">→</span> or <span class="key">A</span> <span class="key">D</span><br>
            Jump: <span class="key">SPACE</span> <span class="key">↑</span> or <span class="key">W</span><br>
            Crouch: <span class="key">↓</span> or <span class="key">S</span><br>
            Run: Hold <span class="key">CTRL</span><br>
            Fire: <span class="key">SHIFT</span> (with Fire Flower)
        </div>
    </div>
</div>

<script>
// ========================================
// ゲーム設定・定数
// ========================================
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

// UI要素
const overlay = document.getElementById('overlay');
const startBtn = document.getElementById('start-btn');
const titleText = document.getElementById('title-text');
const descText = document.getElementById('desc-text');
const levelIndicator = document.getElementById('level-indicator');
const bossHealthContainer = document.getElementById('boss-health-container');
const bossHealthFill = document.getElementById('boss-health-fill');

// ゲーム定数
const TILE_SIZE = 48;
const GRAVITY = 0.55;
const FRICTION = 0.85;
const AIR_FRICTION = 0.92;
const ACCELERATION = 0.6;
const RUN_ACCELERATION = 0.9;
const MAX_SPEED = 7;
const MAX_RUN_SPEED = 11;
const JUMP_FORCE = -14;
const VARIABLE_JUMP_MULTIPLIER = 0.45;

// 高度な物理設定
const COYOTE_TIME = 8;
const JUMP_BUFFER = 8;
const WALL_SLIDE_SPEED = 2;

// ========================================
// サウンドエンジン（Web Audio API）
// ========================================
class SoundEngine {
    constructor() {
        this.ctx = null;
        this.enabled = true;
        this.musicPlaying = false;
        this.currentMusic = null;
        this.musicGain = null;
        this.sfxGain = null;
    }

    init() {
        if (this.ctx) return;
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.musicGain = this.ctx.createGain();
        this.musicGain.gain.value = 0.3;
        this.musicGain.connect(this.ctx.destination);
        this.sfxGain = this.ctx.createGain();
        this.sfxGain.gain.value = 0.5;
        this.sfxGain.connect(this.ctx.destination);
    }

    playNote(freq, duration, type = 'square', volume = 0.3, delay = 0) {
        if (!this.ctx || !this.enabled) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.value = freq;
        gain.gain.value = volume;
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + delay + duration);
        osc.connect(gain);
        gain.connect(this.sfxGain);
        osc.start(this.ctx.currentTime + delay);
        osc.stop(this.ctx.currentTime + delay + duration);
    }

    jump() {
        this.playNote(400, 0.1, 'square', 0.2);
        this.playNote(600, 0.1, 'square', 0.2, 0.05);
    }

    coin() {
        this.playNote(988, 0.1, 'square', 0.2);
        this.playNote(1319, 0.15, 'square', 0.2, 0.1);
    }

    stomp() {
        this.playNote(200, 0.15, 'square', 0.3);
        this.playNote(400, 0.1, 'square', 0.2, 0.05);
    }

    powerup() {
        for (let i = 0; i < 8; i++) {
            this.playNote(300 + i * 100, 0.08, 'square', 0.2, i * 0.06);
        }
    }

    hurt() {
        this.playNote(200, 0.2, 'sawtooth', 0.3);
        this.playNote(100, 0.3, 'sawtooth', 0.2, 0.1);
    }

    die() {
        const notes = [392, 349, 330, 262, 220, 196];
        notes.forEach((n, i) => this.playNote(n, 0.2, 'square', 0.25, i * 0.15));
    }

    victory() {
        const melody = [523, 659, 784, 1047, 784, 1047];
        melody.forEach((n, i) => this.playNote(n, 0.15, 'square', 0.25, i * 0.12));
    }

    bossHit() {
        this.playNote(150, 0.2, 'sawtooth', 0.4);
        this.playNote(100, 0.3, 'square', 0.3, 0.1);
    }

    playMusic(type) {
        if (!this.ctx || !this.enabled) return;
        this.stopMusic();
        
        const melodies = {
            overworld: [
                { notes: [659, 659, 0, 659, 0, 523, 659, 0, 784], durations: [0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.3] },
            ],
            underground: [
                { notes: [196, 233, 262, 311, 262, 233, 196, 0], durations: [0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.2] },
            ],
            castle: [
                { notes: [147, 175, 196, 220, 196, 175, 147, 131], durations: [0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.5] },
            ],
            boss: [
                { notes: [98, 117, 131, 147, 131, 117, 98, 87], durations: [0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.4] },
            ]
        };

        const melody = melodies[type] || melodies.overworld;
        let time = 0;
        
        const playLoop = () => {
            if (!this.musicPlaying) return;
            melody[0].notes.forEach((note, i) => {
                if (note > 0) {
                    this.playMusicNote(note, melody[0].durations[i] * 0.9, time);
                }
                time += melody[0].durations[i];
            });
            this.currentMusic = setTimeout(playLoop, time * 1000);
            time = 0;
        };

        this.musicPlaying = true;
        playLoop();
    }

    playMusicNote(freq, duration, delay) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'square';
        osc.frequency.value = freq;
        gain.gain.value = 0.15;
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + delay + duration);
        osc.connect(gain);
        gain.connect(this.musicGain);
        osc.start(this.ctx.currentTime + delay);
        osc.stop(this.ctx.currentTime + delay + duration);
    }

    stopMusic() {
        this.musicPlaying = false;
        if (this.currentMusic) {
            clearTimeout(this.currentMusic);
            this.currentMusic = null;
        }
    }
}

const sound = new SoundEngine();

// ========================================
// 入力ハンドラー
// ========================================
class InputHandler {
    constructor() {
        this.keys = {
            left: false, right: false, up: false, down: false,
            jump: false, jumpPressed: false, run: false,
            fire: false, firePressed: false
        };
        window.addEventListener('keydown', (e) => this.handleKey(e, true));
        window.addEventListener('keyup', (e) => this.handleKey(e, false));
    }

    handleKey(e, state) {
        if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
            e.preventDefault();
        }
        
        const code = e.code;
        if (code === 'ArrowLeft' || code === 'KeyA') this.keys.left = state;
        if (code === 'ArrowRight' || code === 'KeyD') this.keys.right = state;
        if (code === 'ArrowDown' || code === 'KeyS') this.keys.down = state;
        if (code === 'ControlLeft' || code === 'ControlRight') this.keys.run = state;
        
        // Shiftキーでファイアボール発射
        if (code === 'ShiftLeft' || code === 'ShiftRight') {
            if (state && !this.keys.fire) this.keys.firePressed = true;
            this.keys.fire = state;
        }
        
        if (code === 'Space' || code === 'ArrowUp' || code === 'KeyW') {
            if (state && !this.keys.jump) this.keys.jumpPressed = true;
            this.keys.jump = state;
        }
    }

    update() { this.keys.jumpPressed = false; this.keys.firePressed = false; }
}

// ========================================
// パーティクルシステム
// ========================================
class Particle {
    constructor(x, y, vx, vy, color, size, life, type = 'square') {
        this.x = x; this.y = y;
        this.vx = vx; this.vy = vy;
        this.color = color;
        this.size = size;
        this.life = life;
        this.maxLife = life;
        this.type = type;
        this.rotation = Math.random() * Math.PI * 2;
        this.rotationSpeed = (Math.random() - 0.5) * 0.3;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.2;
        this.life--;
        this.rotation += this.rotationSpeed;
        if (this.type === 'smoke') {
            this.size *= 0.96;
            this.vy -= 0.3;
        }
    }

    draw(ctx, camX, camY) {
        const alpha = this.life / this.maxLife;
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.translate(this.x - camX, this.y - camY);
        ctx.rotate(this.rotation);
        ctx.fillStyle = this.color;
        
        if (this.type === 'star') {
            this.drawStar(ctx, 0, 0, 5, this.size, this.size / 2);
        } else if (this.type === 'circle' || this.type === 'smoke') {
            ctx.beginPath();
            ctx.arc(0, 0, this.size, 0, Math.PI * 2);
            ctx.fill();
        } else {
            ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
        }
        ctx.restore();
    }

    drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
        let rot = Math.PI / 2 * 3;
        let step = Math.PI / spikes;
        ctx.beginPath();
        ctx.moveTo(cx, cy - outerRadius);
        for (let i = 0; i < spikes; i++) {
            ctx.lineTo(cx + Math.cos(rot) * outerRadius, cy + Math.sin(rot) * outerRadius);
            rot += step;
            ctx.lineTo(cx + Math.cos(rot) * innerRadius, cy + Math.sin(rot) * innerRadius);
            rot += step;
        }
        ctx.lineTo(cx, cy - outerRadius);
        ctx.fill();
    }
}

// ========================================
// スプライト描画クラス
// ========================================
class SpriteRenderer {
    // マリオを描画
    static drawMario(ctx, x, y, width, height, facing, frame, isPoweredUp, isInvincible, isCrouching, hasFirePower, starPower) {
        ctx.save();
        ctx.translate(x + width/2, y + height);
        if (facing < 0) ctx.scale(-1, 1);
        
        const h = isCrouching ? height * 0.6 : height;
        
        // スター状態：虹色に点滅
        if (starPower && isInvincible) {
            const colors = ['#ff0000', '#ff8c00', '#ffff00', '#00ff00', '#00bfff', '#8a2be2'];
            const colorIdx = Math.floor(frame / 3) % colors.length;
            ctx.fillStyle = colors[colorIdx];
            // キラキラエフェクト
            if (frame % 5 === 0) {
                ctx.shadowColor = colors[colorIdx];
                ctx.shadowBlur = 20;
            }
        }
        
        // 無敵時の点滅（通常の無敵）
        if (isInvincible && !starPower && Math.floor(Date.now() / 100) % 2 === 0) {
            ctx.globalAlpha = 0.5;
        }
        
        // 体の色を状態に応じて変更
        let hatColor = '#ff0000';
        let shirtColor = '#ff0000';
        let overallColor = '#0000ff';
        
        if (hasFirePower) {
            hatColor = '#ffffff';
            shirtColor = '#ffffff';
            overallColor = '#ff0000';
        } else if (starPower && isInvincible) {
            const colors = ['#ff0000', '#ff8c00', '#ffff00', '#00ff00', '#00bfff'];
            const idx = Math.floor(frame / 2) % colors.length;
            hatColor = colors[idx];
            shirtColor = colors[(idx + 2) % colors.length];
            overallColor = colors[(idx + 4) % colors.length];
        }
        
        // 帽子
        ctx.fillStyle = hatColor;
        ctx.beginPath();
        ctx.ellipse(0, -h + 8, width * 0.5, 8, 0, Math.PI, 0);
        ctx.fill();
        
        // 顔
        ctx.fillStyle = '#ffcc99';
        ctx.beginPath();
        ctx.ellipse(0, -h + 18, width * 0.35, 12, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // 目
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(width * 0.1, -h + 16, 3, 0, Math.PI * 2);
        ctx.fill();
        
        // 鼻
        ctx.fillStyle = '#ffaa77';
        ctx.beginPath();
        ctx.ellipse(width * 0.2, -h + 20, 4, 3, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // 髭
        ctx.strokeStyle = '#4a3728';
        ctx.lineWidth = 2;
        for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.moveTo(width * 0.15, -h + 22 + i * 2);
            ctx.lineTo(width * 0.35, -h + 21 + i * 3);
            ctx.stroke();
        }
        
        // 体
        ctx.fillStyle = shirtColor;
        ctx.fillRect(-width * 0.35, -h + 28, width * 0.7, h * 0.35);
        
        // オーバーオール
        ctx.fillStyle = overallColor;
        ctx.fillRect(-width * 0.38, -h + 28 + h * 0.25, width * 0.76, h * 0.45);
        
        // ボタン
        ctx.fillStyle = '#ffd700';
        ctx.beginPath();
        ctx.arc(-width * 0.15, -h + 28 + h * 0.35, 3, 0, Math.PI * 2);
        ctx.arc(width * 0.15, -h + 28 + h * 0.35, 3, 0, Math.PI * 2);
        ctx.fill();
        
        // 足（アニメーション）
        ctx.fillStyle = '#4a3728';
        const legOffset = Math.sin(frame * 0.3) * 5;
        ctx.fillRect(-width * 0.3, -12, width * 0.25, 12);
        ctx.fillRect(width * 0.05, -12, width * 0.25, 12);
        
        ctx.restore();
    }

    // クリボーを描画
    static drawGoomba(ctx, x, y, width, height, frame) {
        ctx.save();
        ctx.translate(x + width/2, y + height);
        
        // 体
        const squash = 1 + Math.sin(frame * 0.2) * 0.05;
        ctx.scale(squash, 1/squash);
        
        ctx.fillStyle = '#8B4513';
        ctx.beginPath();
        ctx.ellipse(0, -height * 0.6, width * 0.45, height * 0.4, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // 足
        ctx.fillStyle = '#4a3728';
        const walkOffset = Math.sin(frame * 0.3) * 3;
        ctx.beginPath();
        ctx.ellipse(-width * 0.25 + walkOffset, -6, 8, 6, 0, 0, Math.PI * 2);
        ctx.ellipse(width * 0.25 - walkOffset, -6, 8, 6, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // 眉毛（怒り）
        ctx.fillStyle = '#000';
        ctx.save();
        ctx.translate(-width * 0.15, -height * 0.7);
        ctx.rotate(-0.3);
        ctx.fillRect(-6, -2, 12, 3);
        ctx.restore();
        ctx.save();
        ctx.translate(width * 0.15, -height * 0.7);
        ctx.rotate(0.3);
        ctx.fillRect(-6, -2, 12, 3);
        ctx.restore();
        
        // 目
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(-width * 0.15, -height * 0.6, 6, 0, Math.PI * 2);
        ctx.arc(width * 0.15, -height * 0.6, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(-width * 0.12, -height * 0.58, 3, 0, Math.PI * 2);
        ctx.arc(width * 0.18, -height * 0.58, 3, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    }

    // ノコノコを描画
    static drawKoopa(ctx, x, y, width, height, frame, color = 'green') {
        ctx.save();
        ctx.translate(x + width/2, y + height);
        
        const shellColor = color === 'green' ? '#228B22' : '#dc143c';
        const shellDark = color === 'green' ? '#006400' : '#8b0000';
        
        // 甲羅
        ctx.fillStyle = shellColor;
        ctx.beginPath();
        ctx.ellipse(0, -height * 0.5, width * 0.4, height * 0.35, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // 甲羅の模様
        ctx.strokeStyle = shellDark;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.ellipse(0, -height * 0.5, width * 0.25, height * 0.2, 0, 0, Math.PI * 2);
        ctx.stroke();
        
        // 頭
        ctx.fillStyle = '#90EE90';
        ctx.beginPath();
        ctx.ellipse(width * 0.2, -height * 0.75, 10, 12, 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // 目
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(width * 0.25, -height * 0.78, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(width * 0.27, -height * 0.76, 2, 0, Math.PI * 2);
        ctx.fill();
        
        // 足
        ctx.fillStyle = '#FFE4B5';
        const walkOffset = Math.sin(frame * 0.25) * 4;
        ctx.beginPath();
        ctx.ellipse(-width * 0.2 + walkOffset, -8, 8, 8, 0, 0, Math.PI * 2);
        ctx.ellipse(width * 0.15 - walkOffset, -8, 8, 8, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    }

    // クッパを描画
    static drawBowser(ctx, x, y, width, height, frame, health, maxHealth) {
        ctx.save();
        ctx.translate(x + width/2, y + height);
        
        const breathe = Math.sin(frame * 0.1) * 0.03;
        ctx.scale(1 + breathe, 1 - breathe);
        
        // 甲羅
        ctx.fillStyle = '#228B22';
        ctx.beginPath();
        ctx.ellipse(0, -height * 0.4, width * 0.45, height * 0.35, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // トゲ
        ctx.fillStyle = '#F0E68C';
        for (let i = 0; i < 5; i++) {
            const angle = -Math.PI * 0.8 + (i / 4) * Math.PI * 0.6;
            const sx = Math.cos(angle) * width * 0.4;
            const sy = -height * 0.4 + Math.sin(angle) * height * 0.3;
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(sx + Math.cos(angle) * 20, sy + Math.sin(angle) * 20 - 10);
            ctx.lineTo(sx + 8, sy);
            ctx.fill();
        }
        
        // 体
        ctx.fillStyle = '#DAA520';
        ctx.beginPath();
        ctx.ellipse(0, -height * 0.35, width * 0.35, height * 0.25, 0, 0, Math.PI);
        ctx.fill();
        
        // 頭
        ctx.fillStyle = '#90EE90';
        ctx.beginPath();
        ctx.ellipse(width * 0.15, -height * 0.7, width * 0.25, height * 0.2, 0.2, 0, Math.PI * 2);
        ctx.fill();
        
        // 鼻
        ctx.fillStyle = '#228B22';
        ctx.beginPath();
        ctx.ellipse(width * 0.35, -height * 0.68, 12, 8, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // 角
        ctx.fillStyle = '#F0E68C';
        ctx.beginPath();
        ctx.moveTo(width * 0.05, -height * 0.85);
        ctx.lineTo(width * 0.0, -height * 1.05);
        ctx.lineTo(width * 0.15, -height * 0.85);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(width * 0.25, -height * 0.85);
        ctx.lineTo(width * 0.3, -height * 1.05);
        ctx.lineTo(width * 0.35, -height * 0.85);
        ctx.fill();
        
        // 眉毛
        ctx.fillStyle = '#8B0000';
        ctx.save();
        ctx.translate(width * 0.05, -height * 0.78);
        ctx.rotate(-0.4);
        ctx.fillRect(-8, -3, 16, 5);
        ctx.restore();
        ctx.save();
        ctx.translate(width * 0.28, -height * 0.78);
        ctx.rotate(0.2);
        ctx.fillRect(-8, -3, 16, 5);
        ctx.restore();
        
        // 目
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(width * 0.08, -height * 0.72, 8, 0, Math.PI * 2);
        ctx.arc(width * 0.25, -height * 0.72, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#ff0000';
        ctx.beginPath();
        ctx.arc(width * 0.1, -height * 0.71, 4, 0, Math.PI * 2);
        ctx.arc(width * 0.27, -height * 0.71, 4, 0, Math.PI * 2);
        ctx.fill();
        
        // 口
        ctx.fillStyle = '#8B0000';
        ctx.beginPath();
        ctx.ellipse(width * 0.3, -height * 0.58, 15, 8, 0.2, 0, Math.PI);
        ctx.fill();
        
        // 足
        ctx.fillStyle = '#90EE90';
        const walkOffset = Math.sin(frame * 0.15) * 8;
        ctx.beginPath();
        ctx.ellipse(-width * 0.25 + walkOffset, -15, 18, 15, 0, 0, Math.PI * 2);
        ctx.ellipse(width * 0.2 - walkOffset, -15, 18, 15, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // 爪
        ctx.fillStyle = '#F0E68C';
        for (let foot = -1; foot <= 1; foot += 2) {
            const fx = foot < 0 ? -width * 0.25 + walkOffset : width * 0.2 - walkOffset;
            for (let c = 0; c < 3; c++) {
                ctx.beginPath();
                ctx.moveTo(fx - 10 + c * 10, -8);
                ctx.lineTo(fx - 12 + c * 10, 5);
                ctx.lineTo(fx - 5 + c * 10, -8);
                ctx.fill();
            }
        }
        
        ctx.restore();
    }

    // ファイアボールを描画
    static drawFireball(ctx, x, y, size, frame) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(frame * 0.5);
        
        // 外炎
        ctx.fillStyle = '#ff4500';
        ctx.beginPath();
        ctx.arc(0, 0, size, 0, Math.PI * 2);
        ctx.fill();
        
        // 内炎
        ctx.fillStyle = '#ffd700';
        ctx.beginPath();
        ctx.arc(0, 0, size * 0.6, 0, Math.PI * 2);
        ctx.fill();
        
        // 中心
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(0, 0, size * 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    }

    // コインを描画
    static drawCoin(ctx, x, y, size, frame) {
        ctx.save();
        ctx.translate(x, y);
        
        const scaleX = Math.cos(frame * 0.15);
        ctx.scale(scaleX, 1);
        
        // コイン本体
        ctx.fillStyle = '#ffd700';
        ctx.beginPath();
        ctx.ellipse(0, 0, size * 0.4, size * 0.5, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // 光沢
        ctx.fillStyle = '#ffec8b';
        ctx.beginPath();
        ctx.ellipse(-size * 0.1, -size * 0.15, size * 0.15, size * 0.25, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    }

    // はてなブロックを描画
    static drawQuestionBlock(ctx, x, y, size, frame, isEmpty) {
        ctx.save();
        
        const bounce = isEmpty ? 0 : Math.sin(frame * 0.1) * 2;
        ctx.translate(x, y + bounce);
        
        // ブロック本体
        ctx.fillStyle = isEmpty ? '#8B4513' : '#ffa500';
        ctx.fillRect(0, 0, size, size);
        
        // 枠
        ctx.strokeStyle = isEmpty ? '#654321' : '#cc8400';
        ctx.lineWidth = 3;
        ctx.strokeRect(2, 2, size - 4, size - 4);
        
        if (!isEmpty) {
            // ?マーク
            ctx.fillStyle = '#fff';
            ctx.font = `bold ${size * 0.6}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('?', size/2, size/2 + 2);
        }
        
        // ハイライト
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.fillRect(4, 4, size - 8, 6);
        
        ctx.restore();
    }

    // パイプを描画
    static drawPipe(ctx, x, y, width, height) {
        // パイプ本体
        const gradient = ctx.createLinearGradient(x, y, x + width, y);
        gradient.addColorStop(0, '#228B22');
        gradient.addColorStop(0.3, '#32CD32');
        gradient.addColorStop(0.7, '#32CD32');
        gradient.addColorStop(1, '#006400');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(x, y, width, height);
        
        // パイプの口
        ctx.fillStyle = '#32CD32';
        ctx.fillRect(x - 5, y, width + 10, TILE_SIZE * 0.5);
        
        // 光沢
        ctx.fillStyle = 'rgba(255,255,255,0.2)';
        ctx.fillRect(x + 5, y, 8, height);
        
        // 影
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(x + width - 10, y, 8, height);
    }
}

// ========================================
// プレイヤークラス
// ========================================
class Player {
    constructor(game) {
        this.game = game;
        this.width = 32;
        this.height = 44;
        this.x = 100;
        this.y = 100;
        this.vx = 0;
        this.vy = 0;
        this.grounded = false;
        this.facing = 1;
        this.frame = 0;
        this.isPoweredUp = false;
        this.hasFirePower = false;
        this.starPower = false;
        this.isInvincible = false;
        this.invincibleTimer = 0;
        this.fireCooldown = 0;
        this.isCrouching = false;
        this.isDead = false;
        this.scaleX = 1;
        this.scaleY = 1;
        this.coyoteTimer = 0;
        this.jumpBufferTimer = 0;
    }

    reset(x, y) {
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.isDead = false;
        this.grounded = false;
        this.scaleX = 1;
        this.scaleY = 1;
        this.isCrouching = false;
        this.isPoweredUp = false;
        this.hasFirePower = false;
        this.starPower = false;
        this.height = 44;
    }

    update(input) {
        if (this.isDead) return;
        this.frame++;
        
        if (this.isInvincible) {
            this.invincibleTimer--;
            if (this.invincibleTimer <= 0) {
                this.isInvincible = false;
                this.starPower = false; // スター無敵終了
            }
        }
        
        this.isCrouching = input.keys.down && this.grounded;
        
        const maxSpd = input.keys.run ? MAX_RUN_SPEED : MAX_SPEED;
        const accel = input.keys.run ? RUN_ACCELERATION : ACCELERATION;
        
        if (!this.isCrouching) {
            if (input.keys.right) {
                this.vx += accel;
                this.facing = 1;
            } else if (input.keys.left) {
                this.vx -= accel;
                this.facing = -1;
            }
        }
        
        this.vx = Math.max(-maxSpd, Math.min(maxSpd, this.vx));
        
        const fric = this.grounded ? FRICTION : AIR_FRICTION;
        if (!input.keys.left && !input.keys.right) {
            this.vx *= fric;
            if (Math.abs(this.vx) < 0.1) this.vx = 0;
        }
        
        if (this.grounded && Math.abs(this.vx) > 5 && this.frame % 5 === 0) {
            this.game.addParticle(this.x + this.width/2, this.y + this.height, (Math.random() - 0.5) * 2, -Math.random() * 2, '#d4a574', 4 + Math.random() * 3, 20, 'smoke');
        }
        
        this.vy += GRAVITY;
        if (this.vy > 15) this.vy = 15;
        
        if (this.grounded) {
            this.coyoteTimer = COYOTE_TIME;
        } else if (this.coyoteTimer > 0) {
            this.coyoteTimer--;
        }
        
        if (input.keys.jumpPressed) {
            this.jumpBufferTimer = JUMP_BUFFER;
        } else if (this.jumpBufferTimer > 0) {
            this.jumpBufferTimer--;
        }
        
        if (this.jumpBufferTimer > 0 && this.coyoteTimer > 0) {
            this.vy = JUMP_FORCE;
            this.jumpBufferTimer = 0;
            this.coyoteTimer = 0;
            this.grounded = false;
            this.squash(0.7, 1.3);
            sound.jump();
            for (let i = 0; i < 5; i++) {
                this.game.addParticle(this.x + this.width/2, this.y + this.height, (Math.random() - 0.5) * 4, -Math.random() * 3, '#fff', 3 + Math.random() * 2, 15, 'circle');
            }
        }
        
        if (!input.keys.jump && this.vy < -3) {
            this.vy *= VARIABLE_JUMP_MULTIPLIER;
        }
        
        this.x += this.vx;
        this.checkCollisionX();
        
        this.grounded = false;
        this.y += this.vy;
        this.checkCollisionY();
        
        this.scaleX += (1 - this.scaleX) * 0.2;
        this.scaleY += (1 - this.scaleY) * 0.2;
        
        // ファイアボール発射
        if (input.keys.firePressed && this.hasFirePower && this.fireCooldown <= 0) {
            this.shootFireball();
            this.fireCooldown = 15; // 発射間隔
        }
        if (this.fireCooldown > 0) this.fireCooldown--;
        
        if (this.y > this.game.currentMap.height * TILE_SIZE + 100) {
            this.game.playerDie();
        }
    }
    
    shootFireball() {
        const fireball = new Fireball(
            this.game,
            this.x + (this.facing > 0 ? this.width : 0),
            this.y + this.height * 0.4,
            this.facing * 8,
            -2,
            false
        );
        this.game.projectiles.push(fireball);
        sound.powerup();
    }

    squash(x, y) {
        this.scaleX = x;
        this.scaleY = y;
    }

    checkCollisionX() {
        const left = Math.floor(this.x / TILE_SIZE);
        const right = Math.floor((this.x + this.width) / TILE_SIZE);
        const top = Math.floor(this.y / TILE_SIZE);
        const bottom = Math.floor((this.y + this.height) / TILE_SIZE);
        
        for (let y = top; y <= bottom; y++) {
            for (let x = left; x <= right; x++) {
                const tile = this.game.getTile(x, y);
                if (tile === 1 || tile === 2) {
                    if (this.vx > 0) {
                        this.x = x * TILE_SIZE - this.width - 0.01;
                    } else if (this.vx < 0) {
                        this.x = (x + 1) * TILE_SIZE + 0.01;
                    }
                    this.vx = 0;
                }
            }
        }
    }

    checkCollisionY() {
        const left = Math.floor(this.x / TILE_SIZE);
        const right = Math.floor((this.x + this.width) / TILE_SIZE);
        const top = Math.floor(this.y / TILE_SIZE);
        const bottom = Math.floor((this.y + this.height) / TILE_SIZE);
        
        for (let y = top; y <= bottom; y++) {
            for (let x = left; x <= right; x++) {
                const tile = this.game.getTile(x, y);
                
                if (tile === 1 || tile === 2) {
                    if (this.vy > 0) {
                        this.y = y * TILE_SIZE - this.height - 0.01;
                        if (!this.grounded) {
                            this.squash(1.2, 0.8);
                            for (let i = 0; i < 3; i++) {
                                this.game.addParticle(this.x + Math.random() * this.width, this.y + this.height, (Math.random() - 0.5) * 3, -Math.random() * 2, '#d4a574', 3, 15, 'smoke');
                            }
                        }
                        this.grounded = true;
                        this.vy = 0;
                    } else if (this.vy < 0) {
                        this.y = (y + 1) * TILE_SIZE + 0.01;
                        this.vy = 0;
                        // はてなブロックを叩いた
                        this.game.hitBlock(x, y);
                    }
                }
                
                // はてなブロック（タイル値4）も衝突判定
                if (tile === 4) {
                    if (this.vy < 0) {
                        this.y = (y + 1) * TILE_SIZE + 0.01;
                        this.vy = 0;
                        this.game.hitBlock(x, y);
                    }
                }
                
                if (tile === 3 && !this.isInvincible) {
                    this.game.playerHurt();
                }
                
                if (tile === 9) {
                    this.game.nextLevel();
                }
            }
        }
    }

    draw(ctx, camX, camY) {
        if (this.isDead) return;
        ctx.save();
        ctx.translate(this.x - camX + this.width/2, this.y - camY + this.height/2);
        ctx.scale(this.scaleX, this.scaleY);
        ctx.translate(-(this.x - camX + this.width/2), -(this.y - camY + this.height/2));
        SpriteRenderer.drawMario(ctx, this.x - camX, this.y - camY, this.width, this.height, this.facing, this.frame, this.isPoweredUp, this.isInvincible, this.isCrouching, this.hasFirePower, this.starPower);
        ctx.restore();
    }
}

// ========================================
// 敵クラス
// ========================================
class Enemy {
    constructor(game, x, y) {
        this.game = game;
        this.x = x;
        this.y = y;
        this.width = 40;
        this.height = 40;
        this.vx = -1.5;
        this.vy = 0;
        this.alive = true;
        this.frame = 0;
        this.type = 'goomba';
    }

    update() {
        if (!this.alive) return;
        this.frame++;
        
        this.vy += GRAVITY * 0.8;
        this.x += this.vx;
        this.y += this.vy;
        
        const nextX = this.vx > 0 ? this.x + this.width : this.x;
        const tileX = Math.floor(nextX / TILE_SIZE);
        const tileY = Math.floor((this.y + this.height/2) / TILE_SIZE);
        
        if (this.game.getTile(tileX, tileY) === 1) {
            this.vx *= -1;
        }
        
        const bottomY = Math.floor((this.y + this.height) / TILE_SIZE);
        const centerX = Math.floor((this.x + this.width/2) / TILE_SIZE);
        
        if (this.game.getTile(centerX, bottomY) === 1) {
            this.y = bottomY * TILE_SIZE - this.height;
            this.vy = 0;
        }
        
        const aheadX = this.vx > 0 ? centerX + 1 : centerX - 1;
        if (this.game.getTile(aheadX, bottomY) !== 1 && this.vy === 0) {
            this.vx *= -1;
        }
        
        if (this.y > this.game.currentMap.height * TILE_SIZE + 200) {
            this.alive = false;
        }
    }

    draw(ctx, camX, camY) {
        if (!this.alive) return;
        if (this.type === 'goomba') {
            SpriteRenderer.drawGoomba(ctx, this.x - camX, this.y - camY, this.width, this.height, this.frame);
        } else if (this.type === 'koopa') {
            SpriteRenderer.drawKoopa(ctx, this.x - camX, this.y - camY, this.width, this.height, this.frame, this.color);
        }
    }

    stomp() {
        this.alive = false;
        this.game.addScore(100);
        sound.stomp();
        for (let i = 0; i < 8; i++) {
            this.game.addParticle(this.x + this.width/2, this.y + this.height/2, (Math.random() - 0.5) * 6, -Math.random() * 5, '#ffd700', 4, 25, 'star');
        }
    }
}

class Goomba extends Enemy {
    constructor(game, x, y) {
        super(game, x, y);
        this.type = 'goomba';
    }
}

class Koopa extends Enemy {
    constructor(game, x, y, color = 'green') {
        super(game, x, y);
        this.type = 'koopa';
        this.color = color;
        this.height = 48;
        this.vx = -1.2;
    }
}

// ========================================
// ボス（クッパ）クラス
// ========================================
class Bowser {
    constructor(game, x, y) {
        this.game = game;
        this.x = x;
        this.y = y;
        this.width = 96;
        this.height = 96;
        this.vx = 0;
        this.vy = 0;
        this.health = 10;
        this.maxHealth = 10;
        this.alive = true;
        this.frame = 0;
        this.facing = -1;
        this.state = 'idle';
        this.stateTimer = 0;
        this.attackCooldown = 0;
        this.jumpCooldown = 0;
        this.hitTimer = 0;
    }

    update() {
        if (!this.alive) return;
        this.frame++;
        
        if (this.hitTimer > 0) this.hitTimer--;
        
        const player = this.game.player;
        const dx = player.x - this.x;
        this.facing = dx > 0 ? 1 : -1;
        
        this.stateTimer--;
        
        if (this.stateTimer <= 0) {
            const rand = Math.random();
            if (rand < 0.3) {
                this.state = 'chase';
                this.stateTimer = 60;
            } else if (rand < 0.6) {
                this.state = 'attack';
                this.stateTimer = 30;
            } else if (rand < 0.8) {
                this.state = 'jump';
                this.stateTimer = 20;
            } else {
                this.state = 'idle';
                this.stateTimer = 40;
            }
        }
        
        switch (this.state) {
            case 'chase':
                this.vx = this.facing * 2;
                break;
            case 'attack':
                this.vx *= 0.9;
                if (this.attackCooldown <= 0) {
                    this.fireBreath();
                    this.attackCooldown = 60;
                }
                break;
            case 'jump':
                this.vx = this.facing * 3;
                if (this.jumpCooldown <= 0 && this.vy === 0) {
                    this.vy = -12;
                    this.jumpCooldown = 90;
                }
                break;
            default:
                this.vx *= 0.95;
        }
        
        if (this.attackCooldown > 0) this.attackCooldown--;
        if (this.jumpCooldown > 0) this.jumpCooldown--;
        
        this.vy += GRAVITY * 0.9;
        this.x += this.vx;
        this.y += this.vy;
        
        const bottomY = Math.floor((this.y + this.height) / TILE_SIZE);
        const centerX = Math.floor((this.x + this.width/2) / TILE_SIZE);
        
        if (this.game.getTile(centerX, bottomY) === 1) {
            this.y = bottomY * TILE_SIZE - this.height;
            this.vy = 0;
        }
        
        const wallX = this.vx > 0 ? Math.floor((this.x + this.width) / TILE_SIZE) : Math.floor(this.x / TILE_SIZE);
        const wallY = Math.floor((this.y + this.height/2) / TILE_SIZE);
        
        if (this.game.getTile(wallX, wallY) === 1) {
            this.vx *= -0.5;
            if (this.vx > 0) {
                this.x = wallX * TILE_SIZE - this.width - 1;
            } else {
                this.x = (wallX + 1) * TILE_SIZE + 1;
            }
        }
        
        // ボス部屋内に制限
        const minX = this.game.bossAreaStart || 0;
        const maxX = (this.game.currentMap.width - 2) * TILE_SIZE - this.width;
        this.x = Math.max(minX, Math.min(maxX, this.x));
    }

    fireBreath() {
        for (let i = 0; i < 3; i++) {
            setTimeout(() => {
                if (!this.alive) return;
                this.game.projectiles.push(new Fireball(this.game, this.x + (this.facing > 0 ? this.width : 0), this.y + this.height * 0.4, this.facing * (5 + Math.random() * 2), (Math.random() - 0.5) * 3, true));
            }, i * 150);
        }
    }

    takeDamage() {
        if (this.hitTimer > 0) return;
        this.health--;
        this.hitTimer = 60;
        sound.bossHit();
        for (let i = 0; i < 15; i++) {
            this.game.addParticle(this.x + this.width/2, this.y + this.height/2, (Math.random() - 0.5) * 8, (Math.random() - 0.5) * 8, '#ff4500', 6, 30, 'star');
        }
        bossHealthFill.style.width = (this.health / this.maxHealth * 100) + '%';
        if (this.health <= 0) {
            this.defeat();
        }
    }

    defeat() {
        this.alive = false;
        sound.victory();
        for (let i = 0; i < 50; i++) {
            setTimeout(() => {
                this.game.addParticle(this.x + Math.random() * this.width, this.y + Math.random() * this.height, (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10, ['#ff4500', '#ffd700', '#ff6347'][Math.floor(Math.random() * 3)], 8 + Math.random() * 8, 40, 'star');
            }, i * 30);
        }
        setTimeout(() => { this.game.nextLevel(); }, 2000);
    }

    draw(ctx, camX, camY) {
        if (!this.alive) return;
        ctx.save();
        if (this.hitTimer > 0 && Math.floor(this.hitTimer / 4) % 2 === 0) {
            ctx.globalAlpha = 0.5;
        }
        ctx.translate(this.x - camX + this.width/2, this.y - camY + this.height);
        if (this.facing < 0) ctx.scale(-1, 1);
        ctx.translate(-(this.width/2), -this.height);
        SpriteRenderer.drawBowser(ctx, 0, 0, this.width, this.height, this.frame, this.health, this.maxHealth);
        ctx.restore();
    }
}

// ========================================
// ファイアボールクラス
// ========================================
class Fireball {
    constructor(game, x, y, vx, vy, isEnemy = false) {
        this.game = game;
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.size = isEnemy ? 16 : 10;
        this.isEnemy = isEnemy;
        this.alive = true;
        this.frame = 0;
    }

    update() {
        this.frame++;
        this.x += this.vx;
        this.y += this.vy;
        if (!this.isEnemy) {
            this.vy += 0.3;
            const tileY = Math.floor((this.y + this.size) / TILE_SIZE);
            const tileX = Math.floor(this.x / TILE_SIZE);
            if (this.game.getTile(tileX, tileY) === 1) {
                this.vy = -6;
                this.y = tileY * TILE_SIZE - this.size;
            }
        }
        if (this.x < this.game.camera.x - 50 || this.x > this.game.camera.x + canvas.width + 50 || this.y > this.game.currentMap.height * TILE_SIZE) {
            this.alive = false;
        }
    }

    draw(ctx, camX, camY) {
        SpriteRenderer.drawFireball(ctx, this.x - camX, this.y - camY, this.size, this.frame);
    }
}

// ========================================
// アイテムクラス
// ========================================
class Coin {
    constructor(game, x, y) {
        this.game = game;
        this.x = x;
        this.y = y;
        this.width = 24;
        this.height = 32;
        this.collected = false;
        this.frame = 0;
        this.floatY = 0;
    }

    update() {
        this.frame++;
        this.floatY = Math.sin(this.frame * 0.1) * 3;
    }

    draw(ctx, camX, camY) {
        if (this.collected) return;
        SpriteRenderer.drawCoin(ctx, this.x - camX + this.width/2, this.y - camY + this.height/2 + this.floatY, this.height, this.frame);
    }

    collect() {
        if (this.collected) return;
        this.collected = true;
        this.game.coins++;
        this.game.addScore(200);
        sound.coin();
        for (let i = 0; i < 6; i++) {
            this.game.addParticle(this.x + this.width/2, this.y + this.height/2, (Math.random() - 0.5) * 4, -Math.random() * 4, '#ffd700', 5, 20, 'star');
        }
    }
}

class PowerUp {
    constructor(game, x, y, type = 'mushroom') {
        this.game = game;
        this.x = x;
        this.y = y;
        this.width = 32;
        this.height = 32;
        this.vx = type === 'star' ? 3 : 2;
        this.vy = 0;
        this.type = type;
        this.collected = false;
        this.frame = 0;
        // 出現アニメーション
        this.emerging = true;
        this.emergeProgress = 0;
        this.startY = y;
    }

    update() {
        if (this.collected) return;
        this.frame++;
        
        // 出現アニメーション
        if (this.emerging) {
            this.emergeProgress += 2;
            if (this.emergeProgress >= this.height) {
                this.emerging = false;
                this.y = this.startY - this.height;
            }
            return;
        }
        
        // スターは跳ねる
        if (this.type === 'star') {
            this.vy += GRAVITY * 0.4;
            
            // 床との衝突
            const bottomY = Math.floor((this.y + this.height) / TILE_SIZE);
            const centerX = Math.floor((this.x + this.width/2) / TILE_SIZE);
            if (this.game.getTile(centerX, bottomY) === 1 && this.vy > 0) {
                this.y = bottomY * TILE_SIZE - this.height;
                this.vy = -10;
            }
            
            // 天井との衝突（スターが上に飛びすぎないように）
            const topY = Math.floor(this.y / TILE_SIZE);
            if (this.game.getTile(centerX, topY) === 1 && this.vy < 0) {
                this.y = (topY + 1) * TILE_SIZE;
                this.vy = Math.abs(this.vy) * 0.5; // 跳ね返る
            }
            
            // 画面上部の制限（マップ外に出ないように）
            if (this.y < 0) {
                this.y = 0;
                this.vy = Math.abs(this.vy) * 0.5;
            }
        } else {
            this.vy += GRAVITY * 0.5;
            const bottomY = Math.floor((this.y + this.height) / TILE_SIZE);
            const centerX = Math.floor((this.x + this.width/2) / TILE_SIZE);
            if (this.game.getTile(centerX, bottomY) === 1) {
                this.y = bottomY * TILE_SIZE - this.height;
                this.vy = 0;
            }
        }
        
        this.x += this.vx;
        this.y += this.vy;
        
        const wallX = this.vx > 0 ? Math.floor((this.x + this.width) / TILE_SIZE) : Math.floor(this.x / TILE_SIZE);
        const wallY = Math.floor((this.y + this.height/2) / TILE_SIZE);
        if (this.game.getTile(wallX, wallY) === 1) {
            this.vx *= -1;
        }
    }

    draw(ctx, camX, camY) {
        if (this.collected) return;
        ctx.save();
        
        let drawY = this.y - camY;
        let drawHeight = this.height;
        
        // 出現アニメーション中はクリップ
        if (this.emerging) {
            drawY = this.startY - camY - this.emergeProgress;
            ctx.beginPath();
            ctx.rect(this.x - camX - 5, this.startY - camY - this.height - 5, this.width + 10, this.height + 5);
            ctx.clip();
        }
        
        ctx.translate(this.x - camX, drawY);
        
        if (this.type === 'mushroom') {
            // 赤キノコ（スーパーキノコ）
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.ellipse(this.width/2, 10, this.width/2, 14, 0, Math.PI, 0);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(this.width * 0.3, 8, 5, 0, Math.PI * 2);
            ctx.arc(this.width * 0.7, 8, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ffe4b5';
            ctx.fillRect(this.width * 0.3, 10, this.width * 0.4, this.height - 10);
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(this.width * 0.35, this.height - 8, 2, 0, Math.PI * 2);
            ctx.arc(this.width * 0.65, this.height - 8, 2, 0, Math.PI * 2);
            ctx.fill();
        } else if (this.type === 'fireflower') {
            // ファイアフラワー
            const pulse = 1 + Math.sin(this.frame * 0.2) * 0.05;
            ctx.scale(pulse, pulse);
            // 茎
            ctx.fillStyle = '#228B22';
            ctx.fillRect(this.width * 0.4, this.height * 0.4, this.width * 0.2, this.height * 0.6);
            // 葉
            ctx.beginPath();
            ctx.ellipse(this.width * 0.25, this.height * 0.6, 8, 5, -0.5, 0, Math.PI * 2);
            ctx.ellipse(this.width * 0.75, this.height * 0.6, 8, 5, 0.5, 0, Math.PI * 2);
            ctx.fill();
            // 花の中心
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(this.width/2, this.height * 0.3, 8, 0, Math.PI * 2);
            ctx.fill();
            // 花びら（色が変わる）
            const colors = ['#ff0000', '#ff8c00', '#fff'];
            const colorIdx = Math.floor(this.frame / 8) % 3;
            ctx.fillStyle = colors[colorIdx];
            for (let i = 0; i < 5; i++) {
                const angle = (i / 5) * Math.PI * 2 - Math.PI / 2;
                const px = this.width/2 + Math.cos(angle) * 10;
                const py = this.height * 0.3 + Math.sin(angle) * 10;
                ctx.beginPath();
                ctx.arc(px, py, 6, 0, Math.PI * 2);
                ctx.fill();
            }
            // 目
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(this.width * 0.42, this.height * 0.28, 2, 0, Math.PI * 2);
            ctx.arc(this.width * 0.58, this.height * 0.28, 2, 0, Math.PI * 2);
            ctx.fill();
        } else if (this.type === 'star') {
            // スター（無敵）
            const pulse = 1 + Math.sin(this.frame * 0.3) * 0.1;
            const colors = ['#ffd700', '#fff', '#ffec8b'];
            const colorIdx = Math.floor(this.frame / 4) % 3;
            ctx.scale(pulse, pulse);
            ctx.fillStyle = colors[colorIdx];
            this.drawStar(ctx, this.width/2, this.height/2, 5, 14, 7);
            // 目
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(this.width * 0.4, this.height * 0.45, 2, 0, Math.PI * 2);
            ctx.arc(this.width * 0.6, this.height * 0.45, 2, 0, Math.PI * 2);
            ctx.fill();
        } else if (this.type === '1up') {
            // 1UPキノコ（緑）
            ctx.fillStyle = '#32CD32';
            ctx.beginPath();
            ctx.ellipse(this.width/2, 10, this.width/2, 14, 0, Math.PI, 0);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(this.width * 0.3, 8, 5, 0, Math.PI * 2);
            ctx.arc(this.width * 0.7, 8, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ffe4b5';
            ctx.fillRect(this.width * 0.3, 10, this.width * 0.4, this.height - 10);
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(this.width * 0.35, this.height - 8, 2, 0, Math.PI * 2);
            ctx.arc(this.width * 0.65, this.height - 8, 2, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.restore();
    }
    
    drawStar(ctx, cx, cy, spikes, outerR, innerR) {
        let rot = -Math.PI / 2;
        const step = Math.PI / spikes;
        ctx.beginPath();
        ctx.moveTo(cx + Math.cos(rot) * outerR, cy + Math.sin(rot) * outerR);
        for (let i = 0; i < spikes; i++) {
            ctx.lineTo(cx + Math.cos(rot) * outerR, cy + Math.sin(rot) * outerR);
            rot += step;
            ctx.lineTo(cx + Math.cos(rot) * innerR, cy + Math.sin(rot) * innerR);
            rot += step;
        }
        ctx.closePath();
        ctx.fill();
    }

    collect() {
        if (this.collected || this.emerging) return;
        this.collected = true;
        sound.powerup();
        
        const player = this.game.player;
        
        if (this.type === 'mushroom') {
            this.game.addScore(1000);
            if (!player.isPoweredUp) {
                player.isPoweredUp = true;
                player.height = 56; // 大きくなる
                player.y -= 12;
            }
        } else if (this.type === 'fireflower') {
            this.game.addScore(1000);
            player.isPoweredUp = true;
            player.hasFirePower = true;
            player.height = 56;
        } else if (this.type === 'star') {
            this.game.addScore(1000);
            player.isInvincible = true;
            player.invincibleTimer = 600; // 10秒
            player.starPower = true;
        } else if (this.type === '1up') {
            this.game.addScore(0);
            this.game.lives++;
            document.getElementById('lives-display').innerText = `×${this.game.lives}`;
            // 1UPエフェクト
            this.game.show1upText(this.x, this.y);
        }
        
        // パーティクル
        const colors = {
            'mushroom': '#ff0000',
            'fireflower': '#ff8c00',
            'star': '#ffd700',
            '1up': '#32CD32'
        };
        for (let i = 0; i < 12; i++) {
            this.game.addParticle(this.x + this.width/2, this.y + this.height/2, (Math.random() - 0.5) * 6, -Math.random() * 5, colors[this.type], 6, 25, 'star');
        }
    }
}

// ========================================
// ゲームクラス
// ========================================
class Game {
    constructor() {
        this.isRunning = false;
        this.input = new InputHandler();
        this.particles = [];
        this.level = 0;
        this.score = 0;
        this.coins = 0;
        this.lives = 3;
        this.camera = { x: 0, y: 0 };
        this.enemies = [];
        this.items = [];
        this.projectiles = [];
        this.player = new Player(this);
        this.boss = null;
        this.currentMap = null;
        this.frame = 0;
        this.bossAreaStart = 0;
        this.showingLevelIndicator = false;
        this.levelTransitioning = false;
        
        this.levels = [
            { width: 120, height: 14, theme: 'overworld', music: 'overworld', data: [
                "                                                                                                                        ",
                "                                                                                                                        ",
                "                                                                                                                        ",
                "                                                                                                                        ",
                "                                                                                                                        ",
                "                   ?                      ?C?                                                                           ",
                "                                                                                                                        ",
                "  M                              E                  E       E                             ?                    G        ",
                "11111      111         11111111111111     1111111111111111111111       111      111111111111111      1111111111111111111",
                "11111      111    P    11111111111111     1111111111111111111111       111  P   111111111111111      1111111111111111111",
                "11111      111   111   11111111111111  E  1111111111111111111111  E E  111 111  111111111111111   E  1111111111111111111",
                "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
                "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
                "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            ]},
            { width: 100, height: 14, theme: 'underground', music: 'underground', data: [
                "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
                "1                                                                                                1",
                "1                                                                                                1",
                "1       C C C                                                                                    1",
                "1      1111111              ?                                                                    1",
                "1                                        111111                                                  1",
                "1 M                 E             111                  E         E                            G  1",
                "1111         1111111111    11111      E       11111111111111111111      111111       ?       11111",
                "1111         1111111111    11111   1111       11111111111111111111      111111      111     111111",
                "1111     E   1111111111    11111   1111   E   11111111111111111111  E   111111  E   111    1111111",
                "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
                "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
                "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
                "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            ]},
            { width: 100, height: 16, theme: 'castle', music: 'castle', hasBoss: true, data: [
                "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
                "1                                                                                                  1",
                "1                                                                                                  1",
                "1      C   C                                                                                       1",
                "1     11111111          ?                                                                          1",
                "1                                111                                                               1",
                "1 M               E                        E    K                                   B              1",
                "111111       111111111     1111     1111111111111111                                               1",
                "111111       111111111     1111     1111111111111111       1111         11                         1",
                "111111   E   111111111  E  1111  E  1111111111111111  E E  1111    11   11                         1",
                "1111113331111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
                "1111113331111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
                "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
                "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
                "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
                "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            ]}
        ];
    }

    getTile(x, y) {
        if (!this.currentMap) return 1;
        if (x < 0 || x >= this.currentMap.width || y < 0 || y >= this.currentMap.height) return 1;
        
        // 叩かれたブロックかチェック
        const blockKey = `${x},${y}`;
        if (this.hitBlocks && this.hitBlocks.has(blockKey)) {
            return 1; // 空のブロックとして扱う（衝突あり）
        }
        
        const char = this.currentMap.data[y]?.[x];
        if (char === '1') return 1;
        if (char === '2') return 2;
        if (char === '3') return 3;
        if (char === '?') return 4; // はてなブロック
        if (char === '9' || char === 'G') return 9;
        if (char === 'P') return 1; // ドカン（土管）も固体
        return 0;
    }

    loadLevel(idx) {
        this.level = idx;
        this.levelTransitioning = false; // 遷移完了
        const lvl = this.levels[idx];
        this.currentMap = lvl;
        this.enemies = [];
        this.items = [];
        this.projectiles = [];
        this.particles = [];
        this.boss = null;
        this.hitBlocks = new Set(); // 叩かれたブロックを追跡
        this.floatingTexts = []; // 1UPなどのテキスト表示
        
        for (let y = 0; y < lvl.height; y++) {
            for (let x = 0; x < lvl.width; x++) {
                const char = lvl.data[y][x];
                const px = x * TILE_SIZE;
                const py = y * TILE_SIZE;
                
                if (char === 'M') this.player.reset(px, py - this.player.height);
                if (char === 'E') this.enemies.push(new Goomba(this, px, py));
                if (char === 'K') this.enemies.push(new Koopa(this, px, py - 8, 'green'));
                if (char === 'C') this.items.push(new Coin(this, px + 12, py + 8));
                if (char === 'B' && lvl.hasBoss) {
                    this.boss = new Bowser(this, px - 32, py - 96);
                    this.bossAreaStart = px - TILE_SIZE * 5;
                    bossHealthContainer.classList.add('visible');
                    bossHealthFill.style.width = '100%';
                }
            }
        }
        
        document.getElementById('level-display').innerText = `1-${idx + 1}`;
        document.getElementById('score-display').innerText = String(this.score).padStart(6, '0');
        document.getElementById('coins-display').innerText = `×${String(this.coins).padStart(2, '0')}`;
        document.getElementById('lives-display').innerText = `×${this.lives}`;
        
        this.showLevelIndicator(`WORLD 1-${idx + 1}`);
        
        sound.stopMusic();
        setTimeout(() => {
            if (this.isRunning) sound.playMusic(lvl.music || 'overworld');
        }, 1500);
        
        this.camera.x = 0;
        this.camera.y = 0;
        
        if (!lvl.hasBoss) bossHealthContainer.classList.remove('visible');
    }

    showLevelIndicator(text) {
        levelIndicator.innerText = text;
        levelIndicator.style.opacity = '1';
        this.showingLevelIndicator = true;
        setTimeout(() => {
            levelIndicator.style.opacity = '0';
            this.showingLevelIndicator = false;
        }, 2000);
    }

    addParticle(x, y, vx, vy, color, size, life, type) {
        this.particles.push(new Particle(x, y, vx, vy, color, size, life, type));
    }

    addScore(pts) {
        this.score += pts;
        document.getElementById('score-display').innerText = String(this.score).padStart(6, '0');
    }
    
    // はてなブロックを叩いた時の処理
    hitBlock(x, y) {
        const blockKey = `${x},${y}`;
        const char = this.currentMap.data[y]?.[x];
        
        // すでに叩かれたブロックは無視
        if (this.hitBlocks.has(blockKey)) return;
        
        // はてなブロックの場合
        if (char === '?') {
            this.hitBlocks.add(blockKey);
            
            // ブロックバウンスアニメーション
            this.animateBlockBounce(x, y);
            
            // サウンド
            sound.coin();
            
            // ランダムでアイテム決定
            const rand = Math.random();
            let itemType;
            if (rand < 0.70) {
                itemType = 'coin'; // 70% - コイン
            } else if (rand < 0.82) {
                itemType = 'mushroom'; // 12% - スーパーキノコ
            } else if (rand < 0.90) {
                itemType = 'fireflower'; // 8% - ファイアフラワー
            } else if (rand < 0.96) {
                itemType = 'star'; // 6% - スター
            } else {
                itemType = '1up'; // 4% - 1UPキノコ
            }
            
            const px = x * TILE_SIZE;
            const py = y * TILE_SIZE;
            
            if (itemType === 'coin') {
                // コインが飛び出す
                this.spawnCoinFromBlock(px + TILE_SIZE/2, py);
            } else {
                // パワーアップアイテム
                const powerUp = new PowerUp(this, px, py, itemType);
                this.items.push(powerUp);
            }
            
            // パーティクル
            for (let i = 0; i < 5; i++) {
                this.addParticle(px + TILE_SIZE/2, py, (Math.random() - 0.5) * 4, -Math.random() * 3 - 2, '#ffd700', 4, 20, 'star');
            }
        }
    }
    
    // ブロックバウンスアニメーション
    animateBlockBounce(x, y) {
        if (!this.bouncingBlocks) this.bouncingBlocks = {};
        this.bouncingBlocks[`${x},${y}`] = { offset: 0, phase: 0 };
    }
    
    // コインが飛び出す
    spawnCoinFromBlock(x, y) {
        this.coins++;
        this.addScore(200);
        document.getElementById('coins-display').innerText = `×${String(this.coins).padStart(2, '0')}`;
        
        // 飛び出すコインエフェクト
        if (!this.flyingCoins) this.flyingCoins = [];
        this.flyingCoins.push({
            x: x,
            y: y,
            vy: -12,
            life: 30
        });
    }
    
    // 1UPテキスト表示
    show1upText(x, y) {
        this.floatingTexts.push({
            text: '1UP',
            x: x,
            y: y,
            vy: -2,
            life: 60,
            color: '#32CD32'
        });
    }

    playerHurt() {
        if (this.player.isInvincible) return;
        if (this.player.isPoweredUp) {
            this.player.isPoweredUp = false;
            this.player.hasFirePower = false;
            this.player.height = 44; // 元のサイズに戻す
            this.player.isInvincible = true;
            this.player.invincibleTimer = 120;
            sound.hurt();
        } else {
            this.playerDie();
        }
    }

    playerDie() {
        if (this.player.isDead) return;
        this.player.isDead = true;
        this.lives--;
        sound.die();
        document.getElementById('lives-display').innerText = `×${this.lives}`;
        for (let i = 0; i < 20; i++) {
            this.addParticle(this.player.x + this.player.width/2, this.player.y + this.player.height/2, (Math.random() - 0.5) * 8, (Math.random() - 0.5) * 8, '#ff0000', 6, 40, 'circle');
        }
        setTimeout(() => {
            if (this.lives > 0) {
                this.loadLevel(this.level);
            } else {
                this.gameOver();
            }
        }, 2000);
    }

    gameOver() {
        this.isRunning = false;
        sound.stopMusic();
        titleText.innerHTML = 'GAME OVER';
        descText.innerHTML = `Final Score: ${this.score}<br>Coins: ${this.coins}`;
        startBtn.innerText = '★ TRY AGAIN ★';
        overlay.classList.remove('hidden');
        this.lives = 3;
        this.score = 0;
        this.coins = 0;
        this.level = 0;
    }

    nextLevel() {
        if (this.levelTransitioning) return; // 既に遷移中なら何もしない
        this.levelTransitioning = true;
        
        if (this.level + 1 < this.levels.length) {
            sound.victory();
            this.showLevelIndicator('STAGE CLEAR!');
            setTimeout(() => { this.loadLevel(this.level + 1); }, 2500);
        } else {
            this.victory();
        }
    }

    victory() {
        this.isRunning = false;
        sound.stopMusic();
        sound.victory();
        titleText.innerHTML = 'CONGRATULATIONS!';
        descText.innerHTML = `You saved the Princess!<br>Score: ${this.score}<br>Coins: ${this.coins}`;
        startBtn.innerText = '★ PLAY AGAIN ★';
        overlay.classList.remove('hidden');
        bossHealthContainer.classList.remove('visible');
        this.lives = 3;
        this.score = 0;
        this.coins = 0;
        this.level = 0;
    }

    update() {
        if (!this.isRunning || this.showingLevelIndicator || this.levelTransitioning) return;
        this.frame++;
        
        this.player.update(this.input);
        this.input.update();
        
        const targetCamX = this.player.x - canvas.width / 2 + this.player.width / 2;
        this.camera.x += (targetCamX - this.camera.x) * 0.08;
        this.camera.x = Math.max(0, Math.min(this.camera.x, this.currentMap.width * TILE_SIZE - canvas.width));
        
        this.enemies.forEach(e => e.update());
        this.enemies = this.enemies.filter(e => e.alive);
        
        if (this.boss) this.boss.update();
        
        this.items.forEach(item => item.update());
        
        this.projectiles.forEach(p => p.update());
        this.projectiles = this.projectiles.filter(p => p.alive);
        
        this.particles.forEach(p => p.update());
        this.particles = this.particles.filter(p => p.life > 0);
        
        // ブロックバウンスアニメーション更新
        if (this.bouncingBlocks) {
            for (const key in this.bouncingBlocks) {
                const block = this.bouncingBlocks[key];
                block.phase += 0.3;
                block.offset = Math.sin(block.phase) * 8;
                if (block.phase >= Math.PI) {
                    delete this.bouncingBlocks[key];
                }
            }
        }
        
        // 飛び出すコイン更新
        if (this.flyingCoins) {
            this.flyingCoins.forEach(coin => {
                coin.y += coin.vy;
                coin.vy += 0.5;
                coin.life--;
            });
            this.flyingCoins = this.flyingCoins.filter(c => c.life > 0);
        }
        
        // フローティングテキスト更新
        if (this.floatingTexts) {
            this.floatingTexts.forEach(t => {
                t.y += t.vy;
                t.life--;
            });
            this.floatingTexts = this.floatingTexts.filter(t => t.life > 0);
        }
        
        this.checkCollisions();
    }

    checkCollisions() {
        const p = this.player;
        if (p.isDead) return;
        
        this.enemies.forEach(e => {
            if (!e.alive) return;
            if (this.boxCollision(p, e)) {
                // スター状態なら体当たりで敵を倒す
                if (p.starPower && p.isInvincible) {
                    e.stomp();
                    this.addScore(200);
                    for (let i = 0; i < 8; i++) {
                        this.addParticle(e.x + e.width/2, e.y + e.height/2, (Math.random() - 0.5) * 6, (Math.random() - 0.5) * 6, '#FFD700', 5, 25, 'star');
                    }
                } else if (p.vy > 0 && p.y + p.height < e.y + e.height/2) {
                    e.stomp();
                    p.vy = -10;
                    p.squash(0.8, 1.2);
                } else if (!p.isInvincible) {
                    this.playerHurt();
                }
            }
        });
        
        if (this.boss && this.boss.alive) {
            if (this.boxCollision(p, this.boss)) {
                if (p.vy > 0 && p.y + p.height < this.boss.y + this.boss.height * 0.3) {
                    this.boss.takeDamage();
                    p.vy = -12;
                } else if (!p.isInvincible) {
                    this.playerHurt();
                }
            }
        }
        
        this.items.forEach(item => {
            if (item.collected) return;
            if (this.boxCollision(p, item)) {
                item.collect();
            }
        });
        
        // 敵の弾がプレイヤーに当たった場合
        this.projectiles.forEach(proj => {
            if (!proj.alive || !proj.isEnemy) return;
            if (this.boxCollision(p, { x: proj.x - proj.size, y: proj.y - proj.size, width: proj.size * 2, height: proj.size * 2 })) {
                if (!p.isInvincible) this.playerHurt();
                proj.alive = false;
            }
        });
        
        // プレイヤーのファイアボールが敵に当たった場合
        this.projectiles.forEach(proj => {
            if (!proj.alive || proj.isEnemy) return;
            
            // 通常の敵との衝突
            this.enemies.forEach(e => {
                if (!e.alive) return;
                const projBox = { x: proj.x - proj.size, y: proj.y - proj.size, width: proj.size * 2, height: proj.size * 2 };
                if (this.boxCollision(projBox, e)) {
                    e.stomp();
                    proj.alive = false;
                    this.addScore(100);
                    for (let i = 0; i < 8; i++) {
                        this.addParticle(e.x + e.width/2, e.y + e.height/2, (Math.random() - 0.5) * 6, (Math.random() - 0.5) * 6, '#ff4500', 5, 25, 'star');
                    }
                }
            });
            
            // ボスとの衝突
            if (this.boss && this.boss.alive) {
                const projBox = { x: proj.x - proj.size, y: proj.y - proj.size, width: proj.size * 2, height: proj.size * 2 };
                if (this.boxCollision(projBox, this.boss)) {
                    this.boss.takeDamage();
                    proj.alive = false;
                    for (let i = 0; i < 6; i++) {
                        this.addParticle(proj.x, proj.y, (Math.random() - 0.5) * 6, (Math.random() - 0.5) * 6, '#ff4500', 5, 25, 'star');
                    }
                }
            }
        });
    }

    boxCollision(a, b) {
        return a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.y + a.height > b.y;
    }

    draw() {
        if (!this.currentMap) return;
        this.drawBackground();
        this.drawMap();
        this.items.forEach(item => item.draw(ctx, this.camera.x, this.camera.y));
        this.enemies.forEach(e => e.draw(ctx, this.camera.x, this.camera.y));
        if (this.boss) this.boss.draw(ctx, this.camera.x, this.camera.y);
        this.projectiles.forEach(p => p.draw(ctx, this.camera.x, this.camera.y));
        this.player.draw(ctx, this.camera.x, this.camera.y);
        this.particles.forEach(p => p.draw(ctx, this.camera.x, this.camera.y));
        
        // 飛び出すコイン描画
        if (this.flyingCoins) {
            this.flyingCoins.forEach(coin => {
                SpriteRenderer.drawCoin(ctx, coin.x - this.camera.x, coin.y - this.camera.y, 24, this.frame);
            });
        }
        
        // フローティングテキスト描画
        if (this.floatingTexts) {
            ctx.font = 'bold 16px "Press Start 2P", monospace';
            this.floatingTexts.forEach(t => {
                ctx.fillStyle = t.color;
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                const tx = t.x - this.camera.x;
                const ty = t.y - this.camera.y;
                ctx.strokeText(t.text, tx, ty);
                ctx.fillText(t.text, tx, ty);
            });
        }
    }

    drawBackground() {
        const theme = this.currentMap.theme;
        let gradient;
        
        if (theme === 'overworld') {
            gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#5c94fc');
            gradient.addColorStop(0.6, '#87ceeb');
            gradient.addColorStop(1, '#98d8ff');
        } else if (theme === 'underground') {
            gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#000000');
            gradient.addColorStop(1, '#1a1a2e');
        } else if (theme === 'castle') {
            gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#1a0a0a');
            gradient.addColorStop(0.5, '#2d1f1f');
            gradient.addColorStop(1, '#0a0505');
        }
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        if (theme === 'overworld') {
            this.drawClouds();
            this.drawHills();
        } else if (theme === 'castle') {
            this.drawCastleBackground();
        }
    }

    drawClouds() {
        ctx.fillStyle = '#fff';
        const cloudPositions = [{ x: 200, y: 80, s: 1 }, { x: 500, y: 60, s: 1.3 }, { x: 900, y: 100, s: 0.8 }, { x: 1400, y: 50, s: 1.1 }, { x: 2000, y: 90, s: 1 }];
        cloudPositions.forEach(cloud => {
            const x = (cloud.x - this.camera.x * 0.3) % (canvas.width + 400) - 100;
            const y = cloud.y;
            const s = cloud.s;
            ctx.beginPath();
            ctx.arc(x, y, 30 * s, 0, Math.PI * 2);
            ctx.arc(x + 25 * s, y - 10 * s, 25 * s, 0, Math.PI * 2);
            ctx.arc(x + 50 * s, y, 30 * s, 0, Math.PI * 2);
            ctx.arc(x + 25 * s, y + 5 * s, 20 * s, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    drawHills() {
        ctx.fillStyle = '#228B22';
        const hillPositions = [0, 400, 900, 1500, 2200];
        hillPositions.forEach(hx => {
            const x = (hx - this.camera.x * 0.5) % (canvas.width + 600) - 200;
            ctx.beginPath();
            ctx.moveTo(x - 100, canvas.height);
            ctx.quadraticCurveTo(x, canvas.height - 120, x + 100, canvas.height);
            ctx.fill();
        });
        ctx.fillStyle = '#32CD32';
        hillPositions.forEach(hx => {
            const x = (hx + 200 - this.camera.x * 0.5) % (canvas.width + 600) - 200;
            ctx.beginPath();
            ctx.moveTo(x - 60, canvas.height);
            ctx.quadraticCurveTo(x, canvas.height - 70, x + 60, canvas.height);
            ctx.fill();
        });
    }

    drawCastleBackground() {
        ctx.fillStyle = '#ff4500';
        const lavaY = canvas.height - 30;
        ctx.fillRect(0, lavaY, canvas.width, 30);
        ctx.fillStyle = '#ffd700';
        for (let i = 0; i < 10; i++) {
            const bx = (i * 150 + this.frame * 0.5 - this.camera.x * 0.2) % canvas.width;
            const by = lavaY + Math.sin(this.frame * 0.1 + i) * 5;
            ctx.beginPath();
            ctx.arc(bx, by, 5 + Math.sin(this.frame * 0.2 + i) * 3, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    drawMap() {
        const startCol = Math.floor(this.camera.x / TILE_SIZE) - 1;
        const endCol = startCol + Math.ceil(canvas.width / TILE_SIZE) + 2;
        const theme = this.currentMap.theme;
        
        for (let y = 0; y < this.currentMap.height; y++) {
            for (let x = startCol; x <= endCol; x++) {
                if (x < 0 || x >= this.currentMap.width) continue;
                const char = this.currentMap.data[y]?.[x];
                let dx = x * TILE_SIZE - this.camera.x;
                let dy = y * TILE_SIZE - this.camera.y;
                
                // ブロックバウンスオフセット
                const blockKey = `${x},${y}`;
                if (this.bouncingBlocks && this.bouncingBlocks[blockKey]) {
                    dy -= this.bouncingBlocks[blockKey].offset;
                }
                
                if (char === '1') this.drawBlock(dx, dy, theme);
                else if (char === '3') this.drawSpikes(dx, dy);
                else if (char === '?') {
                    // 叩かれたブロックかチェック
                    const isHit = this.hitBlocks && this.hitBlocks.has(blockKey);
                    SpriteRenderer.drawQuestionBlock(ctx, dx, dy, TILE_SIZE, this.frame, isHit);
                }
                else if (char === 'P') SpriteRenderer.drawPipe(ctx, dx, dy, TILE_SIZE, TILE_SIZE * 2);
                else if (char === 'G') this.drawGoalFlag(dx, dy);
            }
        }
    }

    drawBlock(x, y, theme) {
        let color1, color2, borderColor;
        if (theme === 'overworld') { color1 = '#c84c0c'; color2 = '#e09050'; borderColor = '#5c3c28'; }
        else if (theme === 'underground') { color1 = '#1c5a7d'; color2 = '#2d7ab0'; borderColor = '#0d3a52'; }
        else { color1 = '#4a4a4a'; color2 = '#6a6a6a'; borderColor = '#2a2a2a'; }
        ctx.fillStyle = color1;
        ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
        ctx.fillStyle = color2;
        ctx.fillRect(x + 2, y + 2, TILE_SIZE - 4, TILE_SIZE / 2 - 2);
        ctx.fillRect(x + TILE_SIZE / 2, y + TILE_SIZE / 2, TILE_SIZE / 2 - 2, TILE_SIZE / 2 - 2);
        ctx.strokeStyle = borderColor;
        ctx.lineWidth = 2;
        ctx.strokeRect(x + 1, y + 1, TILE_SIZE - 2, TILE_SIZE - 2);
    }

    drawSpikes(x, y) {
        ctx.fillStyle = '#888';
        const spikeWidth = TILE_SIZE / 4;
        for (let i = 0; i < 4; i++) {
            ctx.beginPath();
            ctx.moveTo(x + i * spikeWidth, y + TILE_SIZE);
            ctx.lineTo(x + i * spikeWidth + spikeWidth / 2, y + 8);
            ctx.lineTo(x + (i + 1) * spikeWidth, y + TILE_SIZE);
            ctx.fill();
        }
    }

    drawGoalFlag(x, y) {
        ctx.fillStyle = '#228B22';
        ctx.fillRect(x + TILE_SIZE / 2 - 4, y - TILE_SIZE * 4, 8, TILE_SIZE * 5);
        ctx.fillStyle = '#ff0000';
        ctx.beginPath();
        ctx.moveTo(x + TILE_SIZE / 2 + 4, y - TILE_SIZE * 4);
        ctx.lineTo(x + TILE_SIZE / 2 + 40, y - TILE_SIZE * 3.5);
        ctx.lineTo(x + TILE_SIZE / 2 + 4, y - TILE_SIZE * 3);
        ctx.fill();
        ctx.fillStyle = '#ffd700';
        ctx.beginPath();
        ctx.arc(x + TILE_SIZE / 2, y - TILE_SIZE * 4, 8, 0, Math.PI * 2);
        ctx.fill();
    }
}

// ========================================
// ゲーム初期化とメインループ
// ========================================
let game = null;

// スタートボタン
startBtn.addEventListener('click', () => {
    sound.init();
    if (!game) {
        game = new Game();
    }
    overlay.classList.add('hidden');
    game.isRunning = true;
    game.lives = 3;
    game.score = 0;
    game.coins = 0;
    game.loadLevel(0);
});

// キャンバスリサイズ
function resizeCanvas() {
    const container = document.getElementById('game-container');
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;
}

window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// メインループ
function gameLoop() {
    if (game) {
        game.update();
        game.draw();
    }
    requestAnimationFrame(gameLoop);
}

gameLoop();

console.log('Super Mario Adventure - Fully Loaded!');
</script>
</body>
</html>
